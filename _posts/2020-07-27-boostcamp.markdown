---
layout: post
title: "2020-07-27 TIL"
date: 2020-07-27 13:00:59
author: mollangzzang
categories: TIL
tags: TIL
cover: "/assets/TIL.png"
---

## 표기법이란

> 대부분 알고리즘의 실행 시간은 컴퓨터가 알고리즘을 실행하는 속도에 의존합니다. 이 속도는 컴퓨터의 처리속도, 사용된 언어의 종류, 컴파일러의 속도등에 영향을 받지만 우리는 이러한 시간을 대략적으로 측정할수 있는 방법이 필요해서 나온 것이 표기법입니다.

표기법을 계산하는 방법은 중요하지 않은 항과 상수계수를 제거하고 얼마나 비례해서 증가하는지를 통해 알 수 있습니다.
그 중 가장 **보편적으로 사용되는 표기법이 빅 O 표기법**입니다. 한마디로 표현하자면 **최악의 경우 이정도 걸릴 것이다** 라는 의미로 작성됩니다.

다른 표기법의 종류로는 빅 오메가, 빅 세타등이 존재합니다.

- 빅 오메가

가장 최선의 경우를 의미합니다.

- 빅 세타 표기법

평균적인 상황의 경우를 의미합니다. 빅 O와 빅 오메가의 공통부분입니다. 다만 세타표기법으로 표기 할 수 없는 경우도 있습니다.

## 배열과 연결리스트의 차이

- Linked List

배열에 비해 추가, 삽입, 삭제가 용이합니다. O(1)의 시간복잡도를 가지고 있습니다. 메모리 공간을 낭비하지 않으므로 배열을 많이 선언하지 못하는 경우 사용에 용이할 것 같습니다.

- Array List

추가 ,삽입, 삭제등은 없어진 부분의 공간을 메우기 위해서 나머지 요소들이 움직여야 함으로 O(N)의 시간복잡도를 가집니다. 하지만 탐색에 있어서 O(1)의 시간 복잡도를 가지기 때문에 탐색할 일이 많은 경우 LinkedList 에 비해 뛰어난 성능을 보일 것 같습니다.

- 결론

**탐색**을 자주해야 하는 경우엔 **배열**
**삽입, 삭제, 추가**와 같은 작업이 많다면 **연결 리스트**

## Prototype vs Class

Javascript는 객체지향 언어이다. 하지만 기존의 JS에는 Class라는 개념이 존재 하지 않았고 ECMA 6표준에서 Class 라는 문법이 추가 되었다. 하지만 문법이 추가 된 것이며 JS가 클래스 기반으로 바뀌었음을 의미하진 않는다. 그럼에도 객체지향 언어로 불리는 이유는 프로토타입 기반 언어이기 때문이다. 클래스가 없었으니 상속도 없었고, 따라서 프로토타입을 기반으로 상속을 흉내내도록 구현하여 사용하였다.

## Class

함수 선언과 달리 클래스 선언은 **호이스팅**이 일어나지 않기 때문에, 클래스에 사용하기 위해서는 먼저 선언을 하여야 한다.

    - 호이스팅이란, 함수, 변수와 같이 선언된 것을 코드 최상단으로 끌어올리는 것.

## Prototype

JS에는 Prototype Link 와 Prototype Object가 존재한다. 이 둘을 통틀어 Prototype이라고 부른다.

일반적으로 흔히 쓰는 `let obj = {};` 코드도 `let obj = new Object();` 와 같다.

그렇다면 이러한 사항이 Prototype Object랑 무슨 상관이 있는가?

- 해당 함수에 Constructor 자격 부여
  Constructor 자격이 부여되면 new를 통해 객체를 만들어 낼 수 있게 된다. 이것이 함수만 new 키워드를 사용할 수 있는 이유이다.

- 해당 함수의 Prototype Object 생성 및 연결
  함수를 정의하면 함수만 생성되는 것이 아니라 Prototype Object도 같이 생성이 된다. 그리고 생성된 함수는 prototype이라는 속성을 통해 Prototype Object에 접근이 가능하다. Prototype Object는 일반적인 객체와 같으며, 기본적인 속성으로 constructor , proto 를 가지고 있다.
