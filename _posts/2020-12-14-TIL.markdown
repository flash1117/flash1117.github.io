---
layout: post
title: '스프링부트 공부'
date: 2020-12-14 13:00:59
author: mollangzzang
categories: TIL
tags: TIL
cover: '/assets/TIL.png'
---

MyBatis , iBatis는 ORM이 아니다. SQL Mapper이다.
ORM은 객체를 매핑하는 것이고, SQL Mapper는 쿼리를 매핑한다.

관계형 데이터베이스는 **어떻게 데이터를 저장**할지에 초점이 맞추어진 기술이다.
객체지향 프로그래밍 언어는 메세지를 통해 **기능과 속성을 한 곳에서 관리**하는 기술이다.

이렇게 사상이 다르게 시작을 했기 때문에 **패러다임 불일치**문제가 발생한다. 그러다보니 웹 애플리케이션 개발은 데이터베이스 모델링에만 집중을 하게 되는데 해당 문제를 극복하기 위해서 나온 것이 **JPA**이다.

JPA는 인터페이스로서 자바 표준명세서이다.
인터페이스인 JPA를 사용하기 위해서는 구현체가 필요한데 대표적으로 Hibernate, Eclipse Link 등이 있다. 하지만 Spring에서 JPA를 사용할 때는 이 구현체를 직접 다루지는 않는다.

구현체를 좀 더 쉽게 사용하고자 추상화시킨 Spring Data JPA라는 모듈을 이용해서 JPA를 다루게 된다.

Hibernate를 사용하지 않고 Spring Data JPA를 사용하는 이유는 **구현체 교체의 용이성**과 **저장소 교체의 용이성** 이렇게 2가지 이유가 있다.

구현체 교체의 용이성이란, Hibernate 이외에 다른 구현체로 쉽게 교체하기 위함이다. Hibernate가 언젠자 수명을 다해서 새로운 JPA 구현체가 대세로 떠오를 때 Spring Data JPA를 사용중이라면 아주 손쉽게 교체가 가능하다.
이는 Spring Data JPA 내부에서 구현체 매핑을 지원해 주기 때문이다.

저장소 교체의 용이성이란, 관계형 데이터베이스 외에 다른 저장소로 쉽게 교체하기 위함이다. 서비스 초기에는 관계형 데이터베이스로 모든 기능을 처리했지만, 트래픽이 많아져서 관계형 데이터베이스로는 도저히 감당히 안 될 때가 있다. 이 때 Mongo DB로 교체가 필요하다면 Spring Data JPA에서 Spring Data MongoDB로 의존성만 교체하면 된다. 이는 Spring Data의 하위 프로젝트 들은 기본적인 CRUD의 인터페이스가 같기 때문이다.

위와 같은 이유들로 인해서 Hibernate를 직접 쓰기 보다는 Spring 팀에서 계속해서 Spring Data 프로젝트를 권장하고 있다.

실무에서 JPA를 사용하지 못하는 가장 큰 이유로 **높은 러닝 커브**를 이야기한다.
JPA를 잘 사용하려면 객체지향 프로그래밍과 관계형 데이터베이스를 둘 다 이해해야 한다. 하지만 그만큼 JPA를 사용해서 얻을 수 있는 보상이 크기 때문에 잘 사용하는 것이 중요할 것 같다.

보상이라면, CRUD 쿼리를 직접 작성할 필요가 없고, 부모-자식 관계 표현, 1:N 관계표현, 상태와 행위를 한 곳에서 관리하는 등 객체지향 프로그래밍을 쉽게 할 수 있다는 점이다.

속도 이슈가 있을 수 있지만, 해당 이슈 해결책들이 존재하며 이를 잘 활용하면 네이티브 쿼리만큼의 퍼포먼스를 낼 수 있다. 이 부분에 대해서는 차후에 공부를 해야 할 것 같다.

spring-boot-starter-data-jpa

- 스프링 부트용 Spring Data Jpa 추상화 라이브러리이다.
- 스프링 부트 버전에 맞춰 자동으로 JPA 관련 라이브러리들의 버전을 관리해준다.

h2

- 인메모리형 관계형 데이터베이스이다.
- 별도의 설치가 필요 없이 프로젝트 의존성으로만 관리할 수 있다.
- 메모리에서 실행되기 때문에 애플리케이션을 재시작할 때마다 초기화된다는 점을 이용하여 테스트 용도로 많이 사용된다.
- JPA의 테스트, 로컬 환경에서의 구동에서 사용할 예정

`@Entity`

- 테이블과 링크될 클래스임을 나타냄
- 기본값으로 클래스의 camelcase 이름을 언터스코어 네이밍 `_` 으로 테이블 이름을 매칭한다
- `SalesManager.java` -> `sales_manager table`

`@Id`

- 해당 테이블의 PK 필드를 나타낸다.

`@GeneratedValue`

- PK의 생성 규칙을 나타낸다.
- 스프링 부트 2.0에서는 GenerationType.IDENTITY 옵션을 추가해야만 auto_increment가 된다.

`@Column`

- 테이블의 컬럼을 나타내며 굳이 선언하지 않더라도 해당 클래스의 필드는 모두 컬럼이 된다.
- 사용하는 이유는, 기본값 외에 추가로 변경이 필요한 옵션이 있으면 사용한다.
- 문자열의 경우 VARCHAR(255) 가 기본값인데, 사이즈를 500으로 늘리고 싶거나 타입을 TEXT로 변경하고 싶거나 하는 경우 사용하게 된다.

`@NoArgsConstructor`

- 기본 생성자 자동 추가
- `public Posts() {}` 와 같은 효과

`@Getter`

- 클래스 내 모든 필드의 Getter 메소드를 자동생성

`@Builder`

- 해당 클래스의 빌더 패턴 클래스를 생성
- 생성자 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함

왠만하면 Entity의 PK는 Long 타입의 Auto_increment를 사용하는 것이 좋다. (MySQL 기준으로 이렇게 하면 bigint 타입이 된다) 주민등록번호와 같이 비즈니스상 유니크 키나 여러 키를 조합한 복합키로 PK를 잡을 경우 난감한 상황이 발생한다.

1. FK를 맺을 때 다른 테이블에서 복합키 전부를 갖고 있거나 중간 테이블을 하나 더 둬야하는 상황이 발생한다.
2. 인덱스에 좋은 영향을 끼치지 못한다.
3. 유니크한 조건이 변경될 경우 PK 전체를 수정해야하는 일이 발생한다. 따라서 주민등록번호, 복합키 등은 유니크 키로 별도로 추가하는 것이 좋다.

`@After`

- JUnit에서 단위테스트가 끝날 때마다 수행되는 메소드를 지정
- 보통은 배포 전 전체 테스트를 수행할 때 테스트간 데이터 침범을 막기 위해서 사용한다
- 여러 테스트가 동시에 수행되면 테스트용 데이터베이스인 H2에 데이터가 그대로 남아 있어 다음 테스트 실행 시 테스트가 실패할 수 있다.

`postsRepository.save`

- 테이블 posts에 insert/update 쿼리를 실행한다
- id 값이 있다면 update가, 없다면 insert 쿼리가 실행된다.

`postsRepository.findAll`

- 테이블 posts에 있는 모든 데이터를 조회해오는 메소드이다.

## Spring 웹 계층

### Web Layer

- 흔히 사용하는 컨트롤러(@Controller)와 JSP/Freemarker 등의 뷰 템플릿 영역
- 이외에도 필터(@Fillter), 인터셉터, 컨트롤러 어드바이스(@ControllerAdvice)등 외부 요청과 응답에 대한 전반적인 영역을 의미

### Service Layer

- @Service에 사용되는 서비스 영역
- 일반적으로 Controller와 Dao의 중간 영역에서 사용된다
- @Transactional이 사용되어야 하는 영역

### Repository Layer

- Database와 같이 데이터 저장소에 접근하는 영역
- 기존의 Dao(Data Access Object)영역

### Dtos

- Dto(Data Transfer Object)는 계층 간에 데이터 교환을 위한 객체를 의미하며 Dtos는 이들의 영역
- 예를 들어 뷰 템플릿 엔진에서 사용될 객체나 Repository Layer에서 결과로 넘겨준 객체 등이 이들을 의미한다

### Domain Model

- 도메인이라 불리는 개발 대상을 모든 사람들이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화 시킨 것을 도메인 모델이라고 한다
- 택시 앱이라고 한다면 배차, 탑승, 요금 등이 모두 도메인이 될 수 있다
- @Entity가 사용된 영역이 도메인 모델
- 하지만 무조건 데이터베이스의 테이블과 관계가 있어야만 하는 것은 아니다
- VO처럼 값 객체들도 해당 영역에 속한다
- 비즈니스 로직를 담당하는 곳

</br>
`@WebMvcTest`의 경우 JPA 기능이 작동하지 않는다.
