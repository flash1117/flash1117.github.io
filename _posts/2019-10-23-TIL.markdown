---
layout: post
title:  "2019-10-23 TIL"
date:   2019-10-23 13:00:59
author: mollangzzang
categories: TIL
tags:	TIL C++
cover:  "/assets/TIL.png"
---

C++로 알고리즘을 풀 때 종종 비트 연산자 등이 기억이 헷갈릴 경우가 있다. 그러다가 컴퓨터의 연산자의 우선순위를 제대로 기억하지 못해서 코드를 잘못 짜는 일이 발생하지 않도록 연산자 우선순위를 정리해보려 한다.

#### 연산자 우선순위

1. `x++, x--, ( ), [ ], . ,->`
2. *x 는 포인터 연산 `++x, --x, +x, -x, !, ~, *x , &x, sizeof`
3. 곱셈 나눗셈 나머지연산 `* , / , %`
4. 덧셈 뺄셈`+ , -`
5. 비트 왼쪽 , 오른쪽 시프트 `<< , >>`
6. 크기 비교 연산자 `<, > , <= , >=`
7. 같거나 다름 `== , !=`
8. 비트 AND ` & `
9. 비트 XOR ` ^ `
10. 비트 OR ` | `
11. 논리 AND ` && `
12. 논리 OR ` || `
13. 삼항 연산자 ` ?: `
14. `= , += , -=, *=, /= , %= , <<= , >>= , &= , ^=, |=`
15. comma 연산자 `,`

알고리즘을 풀다보니 최적화에 관해 궁금한 점이 몇가지 생겨서 찾아보다가 C++에 관해 몇가지 알게 되었다.
[Link](https://sites.google.com/site/kokowiki/optimize/cpp_performance)

#### C++ 최적화 팁

1. if , while 문 등의 조건식에서 느린 연산은 뒤로 보낸다.
    - 조건식은 왼쪽에서 오른쪽 방향으로 계산 되게 되는데, 조건식이 여러개일 경우 비확실한 것을 왼쪽으로 보내는 것이다. 그러면 오른쪽 방향의 연산은 수행되지 않을 것이다.

    - 예를 들어 `bool b == false` 인 경우 `if(b || GetResult())` 라는 구문이 있다면 `b = false` 이기 때문에 `GetResult()` 라는 함수를 호출 하지 않게 되서 시간을 절약하게 된다.

2. 값 복사보다 `const &(참조)` 로 값을 넘기고 리턴 받는다.

3. 연산 결과를 저장해서 사용하면 한번 연산한 결과를 되풀이 하지 않게된다.

4. 상속 보다는 template이 빠르다.

5. 생성자와 소멸자는 최소한의 작업만을 한다.

6. 자주 사용하지 않는 멤버변수는 동적으로 생성한다.

7. `char *` 에서 `string` 으로 , 다시 `char *`로 와 같은 변환이 최소한이 되도록 파라미터 타입을 정의한다.

8. **inline / force_inline** 키워드를 적절히 사용하여 인라인 화 한다.
    - 컴파일러에 매우 의존적이다.

9. 생성자 본문 전에 멤버를 초기화한다.

10. 멀티스레드에서 동적으로 할당된 메모리가 **read only** 정보가 될 수 있다면 **TLS** 나 **TSD** 와 같은 thread 로컬 저장소를 이용한다.

11. 데이터 탐색 시 **cpu cache miss** 가 최소화 될 수 있도록 데이터를 밀집시킨다.
    - Linked list 보다는 배열, List 보다는 vector을 사용한다.

12. virtual function 은 컴파일 시 최적화 될 수 없으므로 항상 속도가 느리다. (극복하려면 PGO 등을 사용)

13. 대용량 처리에 STL Container을 사용한다면 allocator의 사용을 고려한다.

14. 연산 결과를 사용할 때 까지 연산을 미룬다.
    - 실행 도중에 조건문에서 리턴될 수 있다면 리턴 이후에 쓸 연산을 미리 할 필요가 없다.

15. Single Thread 라면 함수 안에서 생성하는 사이즈가 큰 지역변수는 static 변수로 만들어서 불필요한 재할당을 막는다.

16. 동일한 입력값에 대해서 동일한 출력값을 갖는 실행시간이 긴 함수가 있다면 입력값을 Key로 하는 출력값 캐시를 만들어서 사용한다.

#### 최적화 원리

1. 생략
    - 샘플링 : 매번 연산하지 않고 연산 빈도를 줄인다.

2. 압축
    - 처리할 데이터의 크기를 줄인다.

3. 캐시(메모이제이션)
    - 한번 연산하여 구한 값을 저장하여 다음 요청시 재사용한다.

4. 모아서 한번에 처리
    - 매번 연산하는 오버헤드를 줄이기 위해 일정 양을 모은 뒤에 한번에 연산한다. 연산 준비과정이나 호출과정 등이 절약된다.

5. 연산축소
    - 복잡한 연산을 단순화된 식으로 줄인다.

6. 분산처리
    - 멀티코어 환경일 경우 동시에 처리할 수 있는 연산을 분산한다.

    - 한 로직을 N개의 Thread 병렬작업으로 분할 할 경우 CPU core 개수에 주의해야 한다. N개의 작업간의 context switching 부하를 최소화 할 수 있는 개수가 되어야 하며 반드시 실험을 통해 검증이 필요하며, 보통 코어 하나당 한개의 스레드가 있는 것이 이상적이다(1개 이상이 이상적인 경우는 thread 들 간의 대기(lock)이 있는 경우이다).

    - CPU utilization 을 항상 고민하라. lock 은 CPU 자원을 100% 사용할 수 없도록 만드는 주된 요인이다. 최대한 lock 을 줄일 수 있는 방향으로, 또 최대한 lock free 알고리즘을 사용하라.

    - 두 스레드가 있고, lock 이 걸릴 확률이 높다면 CPU full utilize가 어렵다. CPU를 다 못쓰고 처리량은 떨어지게된다. 만약 두 스레드간 작업이 동기적일 필요가 없다면(즉, A가 B에게 작업을 넘기고 B작업이 끝날때 까지 기다릴 필요가 없다면), A와 B 스레드 사이에 스레드 C 를 하나 더 넣어서 처리할 작업만 간단히 lockfree로 C에 넣고 A는 실행을 계속하고 C가 B로(Lock) 작업을 넘기도록 하면 CPU를 Full utilize 하는데 도움이 된다. 이는 core 가 1개 일때도 도움이 된다.

7. 특화
    - 일반적이거나 범용적인 처리를 타지 않고 특정 대상만을 위한 별도 특화 처리를 타도록 한다.

8. 반복문 등에서 동일한 연산을 반복할 경우 반복문 밖으로 한번만 연산한다.

    -반복문 안에서 호출되는 함수에 넘기는 파라미터를 조사해서 호출되는 함수 안에서 한번만 수행해도 되는 연산이 반복되지는 않는지 확인해야한다.

    - 예를들어 아래 코드의 경우 obj->Get() 이 readyonly 라면 while 밖에서 구하고 func() 에 파라미터로 전달할 수 있다.

    ```
    while (condition)
    {
        func(obj);
        ...
    }

    func(obj)
    {
        a = obj->Get();
        ...
    }
    ```
9. 재사용
    - 몬스터객체가 있다면, 몬스터가 죽을 때 파괴 생성 비용을 줄이기 위해 죽어도 파괴하지 않고 리셋하여 재사용한다.

10. 동적 -> 정적
    - 코드 작성시 결정되는 동적인 연산을 정적 연산결과로 변경. (컴파일타임)  (ex:_D("abc")  /  #define _D(x)  hashfunc(...x...)

11. 짧은 소유
    - Lock 되어야 할 데이터가 있다면 Lock 해서 데이터를 복제하고 바로 Lock 푼 뒤 복제된 데이터를 쓴다. 공유데이터의 소유시간을 짧게 하여 불필요한 대기시간을 줄여서 CPU full utilization 에 도움을 준다.  

12. 최소 복사
    - 값을 복사해서 쓰는 것을 최소화 한다. int 와 같은 native 형의 복사는 미미할 지 몰라도 string 이나 여러개의 멤버를 가진 객체를 복사하는 비용은 매우 크다.

    - C++ 은 return value 에 있어 값의 복사를 강요하는 한계가 있다. RVO 를 통해 복사를 최소화 한다.

    - C++0x 의 Rvalue Reference 를 이용해서 값의 복사를 최소한으로 줄인다.

    - 수정이 필요없는 파라미터는 최대한 const & 를 사용.