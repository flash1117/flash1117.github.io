---
layout: post
title: "Effective C++ (1)"
date: 2020-11-09 13:00:59
author: mollangzzang
categories: TIL
tags: TIL C++
cover: "/assets/TIL.png"
---

## malloc 과 new의 차이

> malloc은 함수이고 new는 연산자이다.

이로 인해 발생하는 가장 큰 차이는 생성자의 유무이다.
`malloc()`은 시스템 함수로써 함수 안에서 메모리를 할당하지만, new는 연산자로 바로 메모리를 할당하는 것이 아니라 호출하여 메모리를 할당한다. 따라서 생성자를 통하여 호출하기 때문에 new로 메모리를 할당하면 초기화가 가능한 장점이 있다.

## 생성시 초기화 하는 방법

일반적으로 우리가 하는 방법은 생성 후 초기화 이다.

하지만 초기화리스트를 사용하면 **효율성**을 높일 수 있다. 왜냐하면 초기화 리스트를 사용하지 않는 방법은 x ,y 의 메모리 공간이 만들어지고 만들어진 메모리에 대입하는 것이라면, 초기화리스트를 사용한 경우는 x, y의 메모리가 만들어지면서 초기화 되는 것이다.

따라서 초기화 하려는 멤버가 객체라면 **초기화 리스트를 허용한 방법이 더 효율적이다**

## 초기화 리스트 사용법

> 클래스의 각 멤버를 생성자에서 초기화 할 때 생성자 뒤에 콜론연산자(:) 를 사용하여 객체의 멤버를 초기화 할 수 있다. 이를 초기화 리스트 또는 콜론 초기화라고 한다.

## malloc , calloc , realloc

realloc 의 대표적인 문제는 정말 혹시나 메모리 할당이 실패할 경우 null이 반환되기 때문에 기존의 메모리가 할당되어 있는 포인터를 잃어버리는 것이다.

```
int *mem = malloc();
mem = realloc(); // 실패시 mem에는 null이 존재

```

따라서 이러한 점은 메모리 누수로 남게 된다. 이를 방지하기 위해 `realloc()`을 할때는 기존의 메모리 주소를 저장하고 실패시 복구하는 프로세스가 함께 있어야 한다.

## C++ virtual

## C++에서 안전하게 메모리를 해제하는 방법

> 스마트 포인터

## C++ 효과적인 프로그래밍 규칙

> C++을 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라집니다. 그 경우란, 바로 C++의 어떤 부분을 사용하느냐 입니다.

- C언어에서 물려받은 부분
- 객체 지향 개념의 C++
- 템플릿 C++
- STL

## define, const, enum , inline

- 단순한 상수를 쓸 때는, `#define` 보다 const 객체 혹은 enum을 우선적으로 생각해야한다.
- 함수처럼 보이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 먼저 생각하자.

```
//---------------------------------------------------------
// 매크로 함수의 문제점

// a와 b 중에 큰 것을 f에 넘겨 호출합니다.
#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))

int a = 5, b = 0;

CALL_WITH_MAX(++a, b);        // a가 두 번 증가합니다.
CALL_WITH_MAX(++a, b + 10);    // a가 한 번 증가합니다.

// 이렇게 직관적이지 못한 코드가 생성됩니다.


//---------------------------------------------------------
// 반면 인라인 함수에 대한 템플릿은
// 매크로 함수의 효율은 그대로 유지함은 물론
// 정규 함수의 모든 동작 방식 및 타입 안전성까지
// 완벽히 취할 수 있습니다.

template <typename T>
inline void callWithMax(const T& a, const T& b)
{
    f(a > b ? a : b);
}

// T가 정확히 무슨 타입인지 모르기 때문에,
// 매개변수로 상수 객체에 대한 참조자를
// 씁니다.

```

- const 를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는데 도움을 준다. const는 어떤 유효범위에 있는 개체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있고 멤버함수에도 붙을 수 있다.
- 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만 우리는 논리적인 상수성을 사용해서 프로그래밍해야한다.
  - 비트수준 상수성 : 어떤 객체의 멤버 함수가 객체의 정적 멤버를 제외한 데이터 멤버를 건드리지 않은 경우에만 그 멤버 함수가 **const**임을 인정함
  - 논리적인 상수성 : 상수 멤버 함수도 객체의 일부 몇 비트를 바꿀 수 있고 사용자 측에서 알아채지 못하도록 (객체의 상태에 영향을 주지 않도록) 해야한다.
- 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이 때 비상수 버전이 상수 버전을 호출하도록 만든다.

## 객체를 사용하기 전에 반드시 객체를 초기화 하자.

- 기본제공 타입의 객체는 직접 손으로 초기화한다. 경우에 따라서 저절로 되기도 하고 안되기도 하기 때문이다.
- 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 즐겨 사용하자. 그리고 초기화리스트에 데이터멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열하자.
- 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 한다. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.

## 생성자, 소멸자 및 대입 연산자

- c++가 은근슬쩍 만들어 호출해 버리는 함수에 촉각을 세우자

> 컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.

- 컴파일러가 만들어낸 함수가 필요없으면 확실히 이들의 사용을 금해버리자.

> 컴파일러에서 자동으로 제공하는 기능을 허용치 않으려면, 대응되는 멤버 함수를 private으로 선언 한 뒤 구현은 하지 않은채로 두자. Uncopyable과 비슷한 기본 클래스를 쓰는 것도 한 방법이다.

```
class Uncopyable {
protected:                                // 파생된 객체에 대해서
    Uncopyable(void) {}                    // 생성과 소멸을
    ~Uncopyable(void) {}                // 허용합니다.

private:
    Uncopyable(const Uncopyable&);        // 하지만 복사는 방지합니다.
    Uncopyable& operator=(const Uncopyable&);
};

class HomeForSale: private Uncopyable {    // 복사 생성자도,
    ...                                    // 복사 대입 연산자도
};                                        // 이제는 선언되지 않습니다.
```

- 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자

> 다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 한다. 즉, 어떤 클래스가 가상 함수를 하나라도 가지고 있다면 이 클래스의 소멸자도 가상 소멸자여야 한다.

만약, 기본클래스의 소멸자가 가상이 아닌경우 파생클래스의 객체를 기본 클래스의 포인터에 담아 소멸시킬 때 기본 클래스의 소멸자만 호출되어 자원이 누출될 수 있다.

- 기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야 한다.

- 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

> 소멸자에서는 예외가 빠져나가면 안된다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외던지 소멸자에서 모두 받아낸 후에 삼켜 버리던지 프로그램을 끝내든지 해야한다.

발생한 예외를 처리하기 위해 스택 되감기를 하는 도중, 소멸자에서 또 다른 예외가 발생하면 상황에 따라 프로그램이 종료되던지, 정의되지 않은 동작을 보이게 된다. 따라서 소멸자에서 예외가 빠져나가도록 두면 안된다.

```
//-----------------------------------------------------------------------------
// close에서 예외가 발생하면 프로그램을
// 바로 끝냅니다. 대개 abort를 호출합니다.
DBConn::~DBConn(void)
{
    try { db.close(); }
    catch (...) {
        close 호출이 실패했다는 로그를 작성합니다;
        std::abort();
    }
}

// 에러가 발생한 후에 프로그램을 실행을
// 계속할 수 없는 상황이라면 꽤 괜찮은
// 선택입니다.


//-----------------------------------------------------------------------------
// close를 호출한 곳에서 일어난 예외를
// 삼켜 버립니다.
DBConn::~DBConn(void)
{
    try { db.close(); }
    catch (...) {
        close 호출이 실패했다는 로그를 작성합니다;
    }
}

// 대부분의 경우에서 예외 삼키기는
// 그리 좋은 발상이 아닙니다.
// 무엇이 잘못됐는지를 알려 주는 정보가
// 묻혀 버리기 때문입니다.

// 예외 삼키기를 선택한 것이
// 제대로 빛을 보려면,
// 발생한 예외를 그냥 무시한
// 뒤라도 프로그램이 신뢰성
// 있게 실행을 지속할 수 있어야
// 합니다.
```

- 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면 해당 연산을 제공하는 함수는 반드시 보통의 함수여야 한다. (소멸자가 아닌 함수)

- 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자

> 생성자 혹은 소멸자 안에서 가상함수를 호출하지 마라. 가상함수라고 해도 지금 실행중인 생성자나 소멸자에 해당되는 클래스의 파생클래스 쪽으로 내려가지 않으니까

- 대입 연산자는 `*this`의 참조자를 반환하게 하자

단순 대입형 연산자 뿐 아니라, 모든 형태의 대입연산자에서 지켜져야 한다. 이러한 관례를 따르지 않아도 컴파일은 되지만 관례를 따르는 것이 좋다.

- operator= 에서는 자기대입에 대한 처리가 빠지지 않도록 하자

> 원본 객체와 복사대상 객체의 주소를 비교해도 되고, 문장의 순서를 적절히 조정할 수도 있고 복사 후 맞바꾸기 기법을 써도 된다.

```
class Widget {
    ...
    void swap(Widget &rhs);    // *this의 데이터 및 rhs이 데이터를 맞바꿉니다.
    ...
};

Widget& Widget::operator=(const Widget& rhs)
{
    Widget temp(rhs);        // rhs의 데이터에 대해 사본을 하나 만듭니다.
    swap(temp);                // *this의 데이터를 그 사본의 것과 맞바꿉니다.
    return *this;
}

Widget& Widget::operator=(Widget rhs)    // rhs는 넘어온 원래 객체의 사본입니다.
{                                        // (값에 의한 전달)

    swap(rhs);                            // *this의 데이터를 이 사본의
                                        // 데이터와 맞바꿉니다.
    return *this;
}
```

- 객체의 모든 부분을 빠짐없이 복사하자

> 객체 복사함수는 주어진 객체의 모든 데이터 멤버 및 모든 기본 클래스 부분을 빠트리지 말고 복사해야한다. (얕은 복사, 깊은 복사)

> 클래스의 복사 함수 2개(복사생성자, 복사 대입연산자)를 구현할 때, 한쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지마라. 그 대신, 공통된 동작을 제3의 함수에다 분리해놓고 양쪽에서 이것을 호출하게 만들어서 해결하자.

### Ref.

https://makefortune2.tistory.com/246
http://ajwmain.iptime.org/programming/book_summary/%5B00%5Deffective_cpp/effective_cpp.html#C01
