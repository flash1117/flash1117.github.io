---
layout: post
title: "2020-11-09 TIL"
date: 2020-11-09 13:00:59
author: mollangzzang
categories: TIL
tags: TIL
cover: "/assets/TIL.png"
---

## C와 C++의 차이

C++는 C를 확장시킨 언어이며, C는 절차지형의 성격을 띄는 반면 C++은 객체지향 패턴을 따르고 있다.

C에서는 같은 이름을 가진 함수가 존재할 수 없지만, C++에서는 오버로딩, 오버라이딩으로 인해 가능하다.

C에서는 변수 함수를 초기에 작성해야 하지만, C++는 중간에 어디서든 선언이 가능하다.

## OOP

**절차지향,구조적 프로그래밍(C)** : 초창기에 많이 사용한 방법으로 순차적 프로그래밍이라고도 한다. 해야할 작업을 순서대로 코딩을 한다. 구조적 프로그래밍에서는 함수 단위로 구성되며 기능별로 묶어놓은 특징이 있다.

**객체지향 프로그래밍(Java, C++, C#)** : 주 구성요소는 클래스와 객체이다. 그리고 상속과 다형성을 특징으로 들 수 있다. 클래스를 활용하여 각각의 기능별로 구성이 가능하며, 이를 나중에 하나로 합쳐서 프로그램의 완성이 가능하다. 객체 별로 개발이 가능하기에 팀 프로젝트를 하기에도 유리한 장점을 가지고 있다. 또한 코드의 재사용이 가능하며, 오류 발생 가능성이 적고 안정성이 높다.

## 컴파일 언어 스크립트 언어의 차이

스크립트 언어로는 Javascript, python
컴파일 언어의 경우 C, C++ 등이 있다.

컴파일 언어의 경우 컴파일러를 통해서 한번 컴파일 된 후에는 코드 수정 후 재 컴파일을 하기 전까지는 같은 결과를 나타내지만, 스크립트 언어의 경우 실행될 때 바로 해석하므로 코드 변경시 실행 할 때마다 결과가 바뀌게 된다.

## 클래스와 구조체의 차이점

- 구조체는 하나의 구조로 묶일 수 있는 데이터, 변수들의 집합
- 클래스는 변수 뿐 아니라 함수까지 포함시킬수 있다
- C에서도 함수포인터를 사용하여 구조체를 클래스화 시킬수 있다.

## Volatile

> volatile 로 선언된 변수는 외부적인 요인으로 그 값이 언제든지 바뀔 수 있음을 뜻함

## Stack

> 함수로 전달되는 매개변수, 지역변수 등의 임시 변수들이 저장되고 함수 실행 후 돌아갈 복귀 번지또한 저장되는 기억장소

## 세마포어, 뮤텍스의 차이

> 한정된 자원을 여러개의 프로세스들이 사용해야 할 경우, 프로세스들 간에 자원 사용시 충돌이 없도록 하기 위해서 세마포어를 사용한다.

Critical Section을 가진 Thread 들의 running time이 서로 겹치지 않게, 각각 단독을 실행되게 하는 기술이다.

세마포어는 스레드간 재진입이 가능하나 뮤텍스는 오직 한개의 스레드 만이 진입할 수 있다.

## 코드가 컴파일하는 일련의 과정, 단계별 산출물

1. 전처리과정

헤더파일, 매크로함수 같은 **#**으로 시작하는 구문을 처리한다.

2. 컴파일러

전처리기를 거친 뒤 컴파일러로 컴파일을 한다. 컴파일러는 고수준의 언어를 저수준언어로 나타내는 역할을 한다.

3. 어셈블러

저수준의 언어를 완전히 기계어로 바꾸는 역할을 한다. 우리가 읽을 수 없는 영역.

4. 링커

어셈블러가 생성한 obj 파일들을 하나로 합치거나 라이브러리를 합칠 때 링커가 필요하다. 이를통해 exe파일이 탄생.

## 접근 제어 지시자

- private

클래스의 기본 접근 제어 권한이며 외부 접근이 불가능하고, 오로지 해당 클래스 내부의 멤버변수만으로 접근이 가능하다. 또한 상속된 하위클래스도 접근이 불가능하다. 가장 강력한 정보은닉 수단

- protected

파생클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버 처럼 취급된다.

- public

구조체 및 공용체의 기본 접근 제어 권한이며 외부접근이 가능하다.

- 이걸 왜 쓸까?

의도치 않은 코드의 수정을 막고 객체와 객체 간의 간섭이 최대한 없도록 하기 위함

## 인터럽트 처리 루틴

1. CPU에게 인터럽트 요청
2. 현재 작업중인 주소를 메모리에 저장
3. 인터럽트 인지신호 발생
4. 벡터 인터럽트 처리
5. 리턴에 의한 복귀

## 인터럽트 함수와 일반 함수의 차이

일반 서비스 루틴은 CPU가 정해진 시간에 정해진 일을 수행하는 것. state machine 이라고도 한다.
하지만 인터럽트 서비스 루틴은 CPU가 무슨일을 하고 있던 인터럽트 우선순위에 의해서 그 일을 먼저 수행하고 일의 수행 완료 후 다시 일반 서비스 루틴으로 돌아가기 때문에 처리속도의 차이가 난다.

## static 변수

- 변수 선언을 함에 있어서 static 키워드를 사용한 것
- 전역 변수와 비슷한 성격을 가진다.
- 전역 변수는 메모리 공간을 할당받고 초기화가 이루어지면, 프로그램이 종료 될 때까지 소멸되지 않고 초기화도 다시 일어나지 않는다.
- 지역 내 접근을 허용한다는 지역변수의 특징을 제외하면 전역변수에 가깝다.

## Critical Section

임계영역이라고 불리며, 스레드 간에 서로 간섭이 일어나 문제가 일어날 여지가 있는 부분을 위험영역이라고 정하고 이들 구간은 하나의 스레드만이 실행되도록 하는 것

## 동기화란 무엇인가?

- 다중 스레드에서 하나의 자료에 접근할 때 사용한다 (static 으로 선언되어 있거나 배열에 접근하는 경우)

- 예를 들면, 은행계좌에 있는 돈에 대하여 동시에 출금 요청(접근)이 가능하다면 한 쪽에서 출금 처리가 완료되기 전에 다른 쪽에서 출금을 요청하면 출금이 될 수 있기 때문에 반드시 동기화 처리를 해서 작업이 일어나는 중에는 다른 쪽에서의 접근을 막아주어야 한다.

## 포인터란 무엇인가

- 포인터란 메모리 주소를 저장하는 변수이다.

예를 들면 주소를 지칭하고 있는 곳이다. 엘리베이터에서 포인터는 해당 층을 표시하는 버튼이며, 10층 버튼을 누르면 10층으로 이동하듯이 해당 위치를 가리키고 있는 변수이다.

포인터를 사용할 때 주의할 점은 어떠한 주소를 가리키고 있어야 사용이 가능하다.

## 프로세스와 스레드의 차이

프로세스는 실행중인 프로그램을 나타낸다. 이는 CPU가 실행되고 있는 프로세스에 대해서 메모리 자원을 안정되게 분배해주어야 하며 이는 운영체제의 성능에 따라 결정된다. 또한 자식 프로세스와 부모 프로세스가 각각 독립적인 메모리 공간(data, heap, stack)을 가진다.

스레드는 하나의 프로세스 내에서 할당받은 자원을 공유하며 실행되는 독립적인 작업단위이다. 스레드는 각자 stack 메모리 영역을 가지오 있으며 동일한 프로세스 내의 다른 스레드들과 전역 메모리를 공유한다. 따라서 CPU로부터 새로운 자원을 할당받지 않아도 되기에 프로세스보다 실행속도가 빠르다.

스레드는 다른 메모리 공간은 공유하며 stack만 독립적으로 가집니다. 이러한 차이점으로 스레드는 프로세스보다 실행 속도가 빠르다. 이유는 CPU는 한번에 하나의 연산처리 밖에 못하므로 context switching을 하게되는데 프로세스는 메모리 공간이 독립적이어서 data heap stack을 올렸다 내렸다 하는 반면 스레드는 stack만 올렸다 내렸다 하면 되기 때문이다.

## 스레드 생성 방법 과 장단점

생성방법 : Runnable(인터페이스)로 선언되어 있는 클래스를 상속받거나 Thread 클래스를 상속받아 run() 메서드를 구현해주면 된다.

장점 : 빠른 프로세스 생성, 적은 메모리 사용, 쉬운 정보 공유
단점 : 교착 상태에 빠질 수 있다.

## 힙 메모리 영역

힙 영역에는 프로그래머가 동적할당하는 변수에 대한 메모리 영역이며 프로그램이 종료되거나 메모리를 해제 시킬때까지 유지된다.

## 메모리 영역

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Code 영역 : 함수, 제어문, 상수 등등 함수에 대한 기계어 코드가 들어감
Data 영역 : 초기값 있는 전역변수, 배열, static으로 선언된 변수가 들어감
Bss 영역 : 초기값 없는 전역변수, 배열, static으로 선언된 변수가 들어감
Compile time에 크기가 결정되고 이후로 변동되지 않는다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Heap 영역 : 동적할당(malloc)으로 할당된 변수가 들어감. 프로그래머 영역.
Stack 영역 : 지역변수, 블록내에서 할당된 변수가 들어감. 블록을 벗어나면 사라짐
Run time에 Bss와 Heap사이를 기준으로 해서 Heap은 아래로 순차적으로 메모리를 사용하고 Stack은 위쪽으로 순차적으로 메모리를 사용한다
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

## 상속

- 기존의 클래스를 토대로 하여 새로운 클래스를 만드는 방법
- 클래스 A가 클래스 B로부터 상속 받으면 B는 부모클래스, A는 자식클래스가 된다.
- is-a 관계가 성립되어야 한다. (~은 ~이다)

  - Person is a student : “사람”은 “학생”이다. 이것은 성립이 X. 모든 사람이 학생일수는 X.
  - Student is a person : “학생”은 “사람”이다. 이것은 성립이 O. 그래서 우리가 상속 클래스를 만들 때, Student 클래스는 자식클래스로 Person 클래스를 상속할 수 있는 것이다.

- 부모 클래스는 자식 클래스에게 자신의 모든 멤버 변수와 함수를 물려준다. 물론 OOP에서는 물질적인 것 뿐만 아니라, 어떤 기본적인 사람의 특성도 상속의 특성이 될 수 있다.

- 상속받는 클래스를 만들기 위해서 class Student : public [상속할 클래스 이름] 이러한 방법으로 상속이라는 문법을 사용할 수 있다. 상속을 사용한 프로그램은 메모리 공간할당 -> 부모 클래스의 생성자 실행 -> 자식 클래스의 생성자 실행 이라는 순서를 가지게 된다.

## 추상 클래스

- 추상메서드를 하나 이상 가진 클래스이다.
- 자신의 생성자로 객체 생성이 불가능하다. 그 이유는 몸체도 정의되어 있지 않은 추상 클래스의 객체를 만든다는 것은 아무런 의미가 없기 때문. 하지만 추상 클래스의 포인터는 선언이 가능하다.
- 순수가상함수가 하나라도 선언되어있다면 그 클래스는 추상 클래스.
- 하위 클래스를 참조하여 상위 클래스의 객체를 생성한다.
- 하위 클래스를 제어하기 위해 사용한다.

## 인터페이스

- 일종의 추상 클래스
- 오직 추상메서드와 상수만을 멤버로 갖는다
- 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록 한다.

## 다형성

- 서로 다른 객체가 동일한 메세지에 대해 서로 다른 방법으로 응답할 수 있는 기능. 즉 같은 메서드 호출에 대해 서로 다른 방법으로 응답을 하게 되는 것

## 가상함수와 순수가상함수의 차이점

- 객체포인터 변수에 부모클래스와 자식클래스를 담았을 때 오버라이딩된 함수를 실행하게되면 무조건 부모함수를 실행하게된다. 자식클래스에서 재정의한 의미가 없어짐. 그렇기 때문에 virtual이라는 키워드를 사용하여 가상함수로 만들게 된다면 객체포인터 변수에서 각각 해당하는 클래스의 함수를 호출하게 됨.

- 만약 부모클래스에서 재정의 할 함수 앞에 virtual 키워드를 사용하면 자식클래스는 키워드를 적지 않아도 컴파일러에서 자동으로 가상 함수로 정의가 된다. 하지만 소스 코드의 이해를 돕기 위해 자식클래스에서도 virtual 키워드를 적는 것이 관례.

- 순수가상함수는 가상함수와 달리 함수의 선언만 있고 정의는 없는것으로, 자식 클래스에서 반드시 재정의하여야만 한다. 재정의 하지 않는다면 오류 발생.

## 가상테이블

- 클래스 안에 가상함수가 포함되어 있을시 객체를 생성할 때 가상함수를 가리키는 포인터가 생성된다.

- 이 포인터는 가상테이블의 시작주소를 가리키는 포인터고, 각 클래스마다 하나의 고유 가상테이블이 생성되게 됩니다.

- 고유의 가상테이블은 가상함수를 가리키는 함수포인터배열로 되어있다. 즉, 가상 함수를 실행하려면 vptr-> vtable -> func() 를 호출하게 되는 것

## 재귀 함수

재귀함수란 함수 내에서 자기 자신을 다시 호출하는 형태

장점 : 소스코드의 간결화가 가능하다.
단점 : 연산 시간이 오래 걸린다. 또한, 잘못 작성시 프로그램이 무한루프에 빠질 수 있다.

## 디자인패턴 사용 이유

- 디자인패턴이라 여러 프로그래머들의 경험과 지혜를 모아서 공통적인 소프트웨어 디자인 문제를 해결하는데 도움이 될수 있게 만들어 놓은 것

- 가장 대표적인 디자인패턴으로는 싱글톤이 존재. 싱글톤이란 전체 프로그램에서 단 1개의 객체를 생성하고 공유하는데 사용하는 패턴이다. 주로 Android에서 소켓 객체를 사용할 때 사용한다.

## UML이란?

- Unified Modeling Language의 약자로 ‘객체 모델링 언어’ 또는 ‘통합 모델링 언어’를 뜻한다.
- 시스템 설계, 요구분석, 시스템 구현 등의 과정에서 사용되는 모델링 언어로 표기법의 표준화를 목적으로 한다.
- 시스템에 대해 동일한 의미를 공유할 수 있게 하여 언어를 가시화 시킬 수 있고 시스템 구조와 모든 상세 내역에 대해 문서화하여 모델링하는 기능들을 제공하며, 다양한 모델링 도구로서의 다이어그램들로 이루어져 있다.

## UML Diagram의 조류

- 클래스 다이어그램 : 클래스 별로 연관관계를 나타내는 다이어그램
- 유스케이스 다이어그램 : 행위자(Actor)와 UseCase로 구분되어 그려진다.
- 상태 다이어그램 : 현재 상태를 나타내는 다이어그램
- 시퀀스 다이어그램 : 시간의 흐름에 따라서 나타내는 다이어그램
- 액티비티 다이어그램 : 처리과정, 수행되는 동안 일어나는 일을 나타낸다.

## 프로젝트 관리 모형

- 폭포수 : 각 단계를 확실히 매듭 짓고 그 결과를 철저하게 검토 후 승인, 이전 단계로 돌아가기 어려움으로 확실하게 검토해야 함

- 프로토타입 : 사용자의 요구 사항을 정확히 파악하고 결과물을 예측하여 만들어내는 모형물, 사용자에게 미리 보여줄 수 있지만 결과물과 조금 다를 수도 있고 단기간에 만들어야 한다.

- 나선형 모델 : 가장 현실적인 모형으로 비교적 최신형태이다. 점진적으로 개발 과정이 순환하며 진행된다.

## 프레임워크

- 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성되며, 컴포턴트들은 재사용이 가능하다.

- 스켈레톤 코드라고도 불리는데, 특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업 시간을 줄여주는 것이다.

- 장점 : 개발 시간을 줄일 수 있고, 오류로부터 자유로울 수 있다.

- 단점 : 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해질 수 있다.

## 오버로딩 , 오버라이딩

오버로딩 : 같은 이름의 함수를 여러개 정의하는 것. 단 매개변수의 타입이 다르거나 갯수가 달라야한다. 리턴타입이나 접근 제어자에는 영향을 받지 않는다.

오버라이딩 : 상속으로 부모클래스를 물려받았을 때 함수를 하위클래스에서 재정의 하는 것.

## 스마트 포인터

- unique_ptr

`unique_pt`r 은 모던 C++에 속한 스마트 포인터 3가지 중 하나로서 std 네임스페이스에 속해있고 memory 헤더파일에 속한 표준 포인터이다. 다수의 인스턴스가 하나의 객체를 가리키는 것은 프로그램 구조상 복잡해지기에 하나의 소유자 만을 허용하기 위한 용도이다. 새 소유자로 이동은 가능하지만 복사하거나 공유할 수 없다.

- shared_ptr

`shared_ptr`은 둘 이상의 소유자가 메모리에 있는 객체를 공유하는 C++ 표준 라이브러리의 스마트 포인터이다. shared_ptr을 초기화한 후 복사, 함수 인수의 값으로 전달 및 다른 shared_ptr 인스턴스로 할당할 수 있다. 모든 인스턴스는 동일한 객체를 가리키고 새 shared_ptr이 추가되거나 범위를 벗어나거나 다시 설정될 때마다 하나의 “제어 블록”에 대한 액세스를 공유한다. 참조 횟수가 0에 도달하면 delete 키워드를 사용하여 메모리를 해제 하게 된다.

- weak_ptr

`weak_ptr`은 하나 이상의 shared_ptr 인스턴스가 소유하는 객체에 대한 접근을 제공하지만, 소유자의 수에는 포함되지 않는 스마트 포인터이다. shared_ptr은 참조 횟수(reference count)를 기반으로 동작하는 스마트 포인터인데 만약 서로가 상대방을 가리키는 shared_ptr를 가지고 있다면, 참조 횟수는 절대 0이 되지 않으므로 메모리는 영원히 해제되지 않는다. 이렇게 서로가 상대방을 참조하고 있는 상황을 순환 참조(circular reference)라고 한다. weak_ptr은 바로 이러한 shared_ptr 인스턴스 사이의 순환 참조를 제거하기 위해서 사용된다.

### Ref.

https://blog.naver.com/corona78/30083188600
https://dydtjr1128.github.io/cpp/2019/05/10/Cpp-smart-pointer.html
https://91ms.tistory.com/6
