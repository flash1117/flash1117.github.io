---
layout: post
title: "신입 개발자 면접질문 준비 - 네트워크"
date: 2020-11-10 13:00:59
author: mollangzzang
categories: TIL
tags: TIL
cover: "/assets/TIL.png"
---

## OSI 7계층

> 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 규약

- 응용계층

> 사용자가 네트워크에 접근할 수 있도록 서비스를 제공한다.

- 표현계층

> 세션 계층 간의 주고 받는 인터페이스를 일관성 있게 제공한다.

- 세션계층

> 통신 시스템 사용자간의 연결을 유지 및 설정한다.

- 전송계층

> 두 호스트 시스템으로부터 발생하는 데이터 흐름을 제공한다.

- 네트워크계층

> 패킷을 네트워크 간의 IP를 통해서 데이터를 전달한다. 장비로는 라우팅이 있다.

- 데이터링크계층

> 송/수신을 확인한다. MAC Address를 가지고 통신한다. 장비로는 브릿지와 스위치가 있다.

- 물리계층

> 전송하는데 필요한 기능을 제공한다. 장비로는 통신케이블, 허브가 있다.

## TCP/IP 프로토콜 스택 4계층으로 구분

- LINK 계층

> 물리적인 영역의 표준화에 대한 결과. 가장 기본이 되는 영역으로 LAN, WAN, MAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역

- IP 계층

> 경로검색을 하게 해주는 계층. IP 자체는 비연결지향적이며 신뢰할 수 없는 프로토콜이다. 특히 데이터 전송 중에 경로상에 문제가 발생하면 다른 경로를 선택해주는데, 이 과정에서 데이터가 손실되거나 오류가 발생하는 등의 문제가 발생한다고 해서 이를 해결해주지는 않는다. **오류발생에 대비가 없는 프로토콜**이다.

- TCP/UDP 계층 (전송 계층)

> 데이터의 실제 송수신을 담당한다. UDP는 TCP에 비해 상대적으로 간단하며, TCP는 신뢰성 있는 데이터의 전송을 담당한다. 그런데 TCP가 데이터를 보낼 때 기반이 되는 프로토콜이 IP이다. 앞서 말했듯 IP는 신뢰성있는 프로토콜이 아니다. 그 문제의 해결을 해주는 것이 TCP이다. 데이터가 순서에 맞게 올바르게 전송이 갔는지 확인을 해주며 대화를 주고 받는다.

- 응용 계층

> 이러한 서버와 클라이언트를 만드는 과정에서 프로그램의 성격에 따라 데이터 송수신에 대한 약속들이 정해지는데, 이를 가리켜 Application Protocol이라 한다.

## TCP에 대해 설명

- TCP Server의 함수호출 순서 : `socket()` 소켓 생성 -> `bind()` 소켓 주소 할당 -> `listen()` 연결요청 대기상태 -> `accept()` 연결허용 -> `read() / write()` 데이터 송수신 -> `close()` 연결종료

- TCP Client의 함수호출 순서 : `socket()` 소켓 생성 -> `connect()` 연결 요청 -> `read() / write()` 데이터 송수신 -> `close()` 연결종료

- 서버와 클라이언트의 차이점은 **연결요청**이라는 과정이다. 이는 클라이언트 소켓을 생성한 후에 서버로 연결을 요청하는 과정. 서버는 `listen()` 을 호출한 이후부터 연결요청 대기 큐를 만들어 놓는다. 따라서 그 이후부터 클라이언트는 연결요청을 할 수 있다. 이 때 서버가 `accept()`를 호출할 수 있는데 이때는, 연결되기 전까지 호출된 위치에서 블로킹 상태에 놓이게 된다.

- 3-way handshaking : TCP 소켓은 연결설정 과정에서 총 세번의 대화를 주고 받는다.

1. Client는 Server에 접속을 요청하는 SYN(Synchronize Sequence Number) 연결 요청 플래그를 보낸다.

2. Client는 Server의 수락 응답인 ACK와 SYN 패킷을 받고 ACK를 서버로 보내면 연결이 성립된다.

3. 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.

4. 서버는 클라이언트의 요청(FIN)을 받고 알겠다는 확인 메세지로 ACK를 보낸다. 그리고 난 뒤 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다.

5. 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다.

6. 클라이언트는 FIN 메세지를 확인했다는 ACK 메세지를 보낸다.

7. 클라이언트의 ACK 메세지를 받은 서버는 소켓 연결을 종료한다.

8. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비하여 일정시간동안 세션을 남겨놓고 잉여 패킷일 기다리는 과정을 거친다. (TIME_WAIT)

## UDP

- UDP는 TCP의 대안이며, IP와 함께 사용될 때엔 UDP/IP라고 표현하기도 한다.
- TCP의 마찬가지로 실제 데이터 단위를 받기위해 IP를 사용한다. 하지만 TCP와 달리 메세지를 패킷으로 나누고 반대편에서 재조립하는 서비스를 제공하지 않는다.
  즉 여러 컴퓨터를 거치지 않고 데이터를 주고 받은 컴퓨터끼리 직접 연결하고자 할 때 UDP를 사용한다.
- UDP를 사용해서 목적지(IP)로 메세지를 보낼 수 있고, 컴퓨터를 거쳐서 목적지까지 도달할 수도 있다. 하지만 도착하지 않을 수도 있다. 정보를 받는 컴퓨터에서는 포트를 열어두고 패킷이 올 때까지 기다리며 데이터가 온다면 모두 다 받아들인다. 패킷이 도착했을 때 출발지에 대한 정보 (IP, PORT) 를 알 수 있다.
- UDP는 이러한 특성으로 인해 안정적이지 않는 프로토콜이다. 하지만 TCP에 비해 속도가 빠른 편이기에 데이터 유실이 일어나도 상관없는 스트리밍이나 화면전송에 사용된다.

## Multi-Thread Server

- 듣기 소켓을 통해 새로운 클라이언트가 들어오면 fork 함수를 통해 자식프로세스를 만드는 대신에 thread_create 함수를 이용해서 새로운 스레드를 만드는 것이다. 이 스레드는 문맥을 포함한 코드 조각으로 듣기 소켓의 소켓지정번호를 매개변수로 받아들일 수 있다. 이 듣기 소켓을 이용해서 클라이언트를 처리하는 식이다.

- 핵심은 서버 프로그램이 듣기 소켓과 연결 소켓이 분리되어 있는데, 듣기 소켓에 클라이언트 연결이 들어와서 연결 소켓이 만들어지면 스레드를 만들어 클라이언트 요청을 처리하는데 있다.

- 스레드는 프로세스를 복사하는 멀티 프로세스 방식보다 좀 더 작고 빠르게 동작하는 프로그램을 만들 수 있다. 하지만 독립된 프로세스 단위로 구동되지 않기 때문에 디버깅이 힘들고 하나의 스레드로 발생한 문제가 전체 프로세스에 영향을 미칠 수 있다는 문제점이 있다.

## IOCP

- IOCP는 어떤 I/O 핸들에 대해서, 블록 되지 않게 비동기 IO 작업 함으로 프로그램 대기시간을 줄이는 목적으로 사용된다. 우선 Overlapped IO 개념이 기반이 된다. IOCP는 이런 Overlapped IO가 실행이 되고 알려주는 방법에 대한 것이다.

- 동기화 오브젝트 세마포어의 특성과 큐를 가진 커널 오브젝트이다. 스레드 상에서 사용되며 대부분 여러 스레드, 멀티 스레드 상에서 사용된다. 큐를 자체적으로 운영하는 특징때문에 스레드 풀링에 적합하다.

- 동기화와 동시에 큐를 통한 데이터전달(완료알림) IOCP는 **스레드 풀링**을 위한 것이라 할 수 있다.
  - 풀링이란, 여러 스레드를 생성하여 대기시켜놓고 필요할 때 가져다가 사용 후 다시 반납하는 과정이다. 스레드 생성과 파괴에는 상당한 오버헤드가 있기 때문

**장점**

- 사용자가 설정한 버퍼만을 사용하기 때문에 더 효율적으로 작동한다. 기존에는 OS버퍼, 사용자 버퍼로 따로 분리되는 개념이었다.
- IO요청에 대해서 효율적으로 접근한다. 디스크 IO의 경우 디스크에 접근을 효율적으로 한다. 순서대로가 아닌 효율적인 순서에 따라 접근하기도 함. 즉, 커널레벨에서는 모든 IO를 비동기적으로 처리한다.

**주의사항**

- 소켓생성(WSASocket)을 할 때 마지막에 반드시 WSA_FLAG_OVERLAPPED를 넣어줘야함
- WSASend, WSARecv 사용 할 때 Overlapped구조체를 넣어줄것

### Ref.

https://91ms.tistory.com/5?category=711086
