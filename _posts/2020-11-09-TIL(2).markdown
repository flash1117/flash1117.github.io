---
layout: post
title: "Effective C++ 자원관리"
date: 2020-11-09 13:00:59
author: mollangzzang
categories: TIL
tags: TIL C++
cover: "/assets/TIL.png"
---

## 자원관리에는 객체

> 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII(Resource Acquisition Is Initialization) 객체를 사용하자

> 일반적으로 널리 쓰이는 RAII 클래스는 `tr1::shared_ptr` , `auto_ptr` 이다. 이 둘 가운데 `tr1::shared_ptr`이 복사 시의 동작이 직관적이기 때문에 대게 더 좋다. 반면 `auto_ptr`은 복사되는 객체(원본 객체)를 null로 만들어 버린다.

## 자원 관리 클래스의 복사 동작에 대한 진지한 고찰이 필요하다

> RAII 객체의 복사는 그 객체가 관리하는 자원의 복사 문제를 안고 가기 때문에 그 자원을 어떻게 복사하는냐에 따라 RAII 객체의 복사 동작이 결정된다.

> RAII 클래스에 구현하는 일반적인 복사 동작은 복사를 금지하거나 참조 카운팅을 해주는 선으로 마무리하는 것이다. 하지만 이외의 방법도 가능하다

- 복사를 금지한다.
- 관리하고 있는 자원에 대해 참조 카운팅을 수행한다. (tr1::shared_ptr)
- 관리하고 있는 자원을 진짜로 복사한다.
- 관리하고 있는 자원의 소유권을 옮긴다. (auto_ptr)

## 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자

- 실제 자원을 직접 접근해야하는 기존 API들도 많기 때문에, RAII 클래스를 만들 때는 그 클래스가 관리하는 자원을 얻을 수 있는 방법을 열어주어야 한다.

- 자원 접근은 명시적 변환 혹은 암시적 변환을 통해 가능하다. 안전성만 따지만 명시적 변환이 대체적으로 더 낫지만, 고객 편의성을 놓고 보면 암시적 변환이 괜찮다.

## new 및 delete를 사용할 때는 형태를 반드시 맞추자

> new 표현식에 []를 썼으면, 대응되는 delete 표현식에도 []를 사용해야 한다. 마찬가지로 new 표현식에 []를 쓰지 않았다면 대응되는 delete에도 사용하지 말아야 한다.

## new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자

> new로 생성한 객체를 스마트 포인터로 넣는 코드는 별도의 한 문장을 만들자

이것이 되어 있지 않다면, 예외가 발생할 때 디버깅하기 힘든 자원 누출이 초래될 수 있다.

```
processWidget(std::tr1::shared_prt<Widget>(new Widget), priority());
// 이런 식으로 코드를 작성한 경우 매개변수의 평가 순서가 정해지지 않은 C++에서
// 다음과 같은 순서로 작동한 경우 메모리 누수가 일어날 수 있습니다.

// 1. "new Widget"을 실행합니다.
// 2. priority를 호출합니다.
// 3. tr1::shared_prt 생성자를 호출합니다.
// 이 때 priority 호출 부분에서 예외가 발생하면
// "new Widget"으로 만들어졌던 포인터가 유실됩니다.
```

## 인터페이스 설계

- 좋은 인터페이스는 제대로 쓰기엔 쉽고 엉터리로 사용하기엔 어렵다. 인터페이스를 만들때 이 특성을 지닐 수 있도록 고민하자.

- 인터페이스의 올바른 사용을 이끄는 방법으로는 인터페이스 사이의 일관성 잡아주기, 그리고 기본제공 타입과의 동작 호환성 유지하기가 있다.

- 사용자의 실수를 방지하는 방법으로는 새로운 타입 만들기, 타입에 대한 연산을 제한하기, 객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기가 있다.

예시 )

1. 새로운 타입 만들기: month, day등을 int를 사용하여 표현하기보다 별도의 타입을 만든다.

2. 타입에 대한 연산을 제한하기: a \* b = c 같은 연산은 허용하지 않는 것이 좋다.

3. 객체의 값에 대해 제약 걸기: month가 갖는 값은 1~12월 밖에 없으므로 이 외의 값은 갖지 못하게 한다.

4. 자원 관리 작업을 사용자의 책임으로 놓지 않기: 팩토리 함수의 반환값을 스마트 포인터로 만든다면 사용자가 자원을 반환하지 않아 발생하는 자원의 누수를 막을 수 있다.

- tr1::shared_ptr은 사용자 정의 삭제자를 지원한다.

  - 이 특징으로 인해 tr1::shared_ptr은 교차 DLL 문제를 막아주며, 뮤텍스 등을 자동으로 잠금 하제하는데 쓸 수 있다.

- 교차 DLL 문제

> 객체 생성 시에 어떤 동적 링크 라이브러리(dll)의 new를 썼는데 그 객체를 해제할 때는 이전의 dll과 다른 dll에 있는 delete를 사용해서 발생하는 문제

```
std::tr1::shared_ptr<Investment> createInvestment(void)
{
    std::tr1::shared_ptr<Investment> retVal(static_cast<Investment*>(0),
                                            getRidOfInvestment);
                            // getRidOfInvestment는 Investment 객체를
                            // 소멸시키는 삭제자 입니다.

                            // shared_ptr은 두 번째 인자로 지정한
                            // 삭제자를 통해 자원을 해제합니다.

    retVal = ... ;            // retVal은 실제 객체를 가리키도록
                            // 만듭니다.
    return retVal;
}
```

## 클래스 설계

- 클래스 설계는 타입 설계이다.

따라서 새로운 타입을 정의하기 전에 다음의 고려사항을 체크해보자.

- 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가?

이 부분에 따라 클래스의 생성자 및 소멸자의 설계가 바뀐다. 그뿐 아니라 메모리 할당 연산자 함수를 오버로딩 하는 경우에는 이들 연산자 함수의 설계에도 영향을 미친다.

- 객체 초기화는 객체 대입과 어떻게 달라야 하는가?

생성자와 대입 연산자의 동작 및 둘 사이의 차이점을 결정짓는 요소이다.

- 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?

여기서 잊으면 안되는 중요한 사실은 **값에 의한 전달**을 구현하는 쪽은 **복사 생성자**이다.

- 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?

전부는 아니지만, 클래스의 데이터 멤버의 몇 가지 조합 값만은 반드시 유효해야 한다. 이런 조합을 가리켜 클래스의 **불변속성(invariant)**이라고 하며, 클래스 차원에서 지켜주어야 하는 부분이다.

이 불변속성에 따라 클래스 멤버 함수 안에서 해 주어야 할 에러점검 루틴이 좌우되는데, 특히 생성자, 대입 연산자, 각종 쓰기 함수는 불변속성에 많이 좌우된다. 뿐만 아니라 불변속성은 함수가 발생시키는 예외에도 영향을 미치며, 예외지정을 쓴다면 그 부분에도 영향을 미친다.

- 기존의 클래스 상속 계통망 (inheritance graph)에 맞출것인가?

이미 갖고 있는 클래스로부터 상속을 시킨다고 하면, 클래스의 설계는 이들 클래스에 의해 제약을 받게 됩니다. 특히 멤버 함수의 가상성 여부가 가장 큰 요인이다.
만약 직접 만든 클래스를 다른 클래스들이 상속할 수 있게 만들자고 결정했다면, 이에 따라 멤버 함수의 가상 함수 여부가 결정된다. (특히 소멸자)

- 어떤 종류의 타입 변환을 허용할 것인가?

암시적 타입 변환과 명시적 타입 변환 중 허용할 타입 변환을 정한다.

- 어떤 연산자와 함수를 두어야 의미가 있을까?

클래스 안에 선언할 멤버 함수가 여기서 결정된다. 멤버 함수로 적당한 함수와 그렇지 않은 함수가 있을 것이다.

- 표준 함수들 중 어떤 것을 허용하지 말 것인가?

private으로 선언해야 하는 함수가 여기에 해당된다.

- 새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줄 것인가?

어떤 클래스 멤버를 public, protected, private 영역에 둘 것인가를 결정하는데 도움을 주게 될 질문이다. 또한 프렌드로 만들어야 할 클래스 및 함수를 결정하는 것은 물론이고 한 클래스를 다른 클래스에 중첩시켜도 되는가에 대한 결정을 내리는데도 이 질문이 도움이 된다.

- 선언되지 않은 인터페이스로 무엇을 둘 것인가?

만든 타입이 제공할 보장이 어떤 종류일까에 대한 질문으로서, 보장할 수 있는 부분은 수행 성능 및 예외 안정성 그리고 자원사용(잠금 및 동적 메모리) 입니다. 이들에 대해 보장하겠다고 결정한 결과는 클래스 구현에 있어서 제약으로 작용하게 된다.

- 새로 만드는 타입이 얼마나 일반적인가?

정의하는 클래스가 타입 하나가 아니라 동일 계열의 타입군 전체일지도 모른다. 만일 그렇다면 새로운 클래스가 아니라 새로운 클래스 템플릿을 정의해야 한다.

- 정말 꼭 필요한 타입인가?

기존의 클래스에 대해 기능 몇개가 아쉬워서 파생 클래스를 새로 만들기보다는, 차라리 간단하게 비멤버 함수라든지 템플릿을 몇개 더 정의하는 편이 좋다.

## 값에 의핸 전달, 상수 객체 참조자에 의한 전달

- 값에 의한 전달보다는 상수 객체 참조자에 의한 전달을 선호하자. 대체적으로 효율적일 뿐 아니라 복사손실의 문제까지 막아준다.

- 이번 항목에서 다룬 법칙은 기본제공 타입 및 STL 반복자, 그리고 함수 객체 타입에는 맞지 않다. 이들에 대해서는 값에 의한 전달이 더 적절하다.

## 함수에서 객체를 반환해야 할 경우 참조자를 반환하려고 들지 말자

- 지역 스택 객체에 대한 포인터나 참조자를 반환하는 일, 혹은 힙에 할당된 객체에 대한 참조자를 반환하는 일 또는 지역 정적 객체에 대한 포인터나 참조자를 반환하는 일은 그런 객체가 2개 이상 필요해질 가능성이 있다면 절대로 해선 안된다.

### Ref.

https://comfun.tistory.com/entry/c-c-%EB%A9%B4%EC%A0%91
