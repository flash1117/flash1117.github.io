---
layout: post
title: "신입 개발자 면접질문 준비 - 운영체제"
date: 2020-11-10 13:00:59
author: mollangzzang
categories: TIL
tags: TIL
cover: "/assets/TIL.png"
---

## CPU

> 중앙처리 장치로서 컴퓨터의 연산을 담당한다.

> 내부에 ALU, Control Unit, Register set, Bus Interface가 있다.

## Main Memory

> RAM이라는 저장장치로 구성된다.

> 컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역, 프로그램이 실행되기 위해 존재한다.

## I/O Bus

> 컴퓨터를 구성하는 구성요소 사이에서 데이터를 주고 받기위해 사용되는 경로

> 데이터의 종류와 역할에 따라 address bus, data bus, control bus 로 구분된다.

## 32bit와 64bit의 구분

> 한번의 송 수신 할 수 있는 데이터의 크기 & 한번에 처리 할 수 있는 데이터의 크기를 기준으로 삼는다

## 프로그램의 실행 과정

1. 전처리기 - **#**이 붙어있는 헤더파일 또는 매크로 함수 같은 것을 처리하는 과정

2. 컴파일러 - 개발자가 작성한 소스코드를 어셈블러가 읽을 수 있도록 변환시켜주는 역할

3. 어셈블러 - 컴퓨터만 읽을 수 있는 바이너리 코드를 생성한다.

4. 링커 - 생성된 obj 파일들을 합쳐서 실행파일을 생성한다.

## 스케쥴링

> CPU 할당 순서 및 방법을 결정하는 일 (어떤 프로세스를 running 상태로 보낼까?)

대부분의 OS에서는 우선순위 알고리즘과 라운드 로빈을 혼합해서 스케줄링 하는 것으로 알고있다.

## Context Switching

> Running 상태의 Task가 사용하던 context를 메모리 특정 영역에 저장한 후 새로이 수행될 Task의 context를 PCB 또는 Stack 에서 CPU의 레지스터 영역으로 복사하여 새로운 Task가 수행되도록 하는 일련의 작업.

- Context Switch Overhead

- 해결방안

1. Context Switch가 자주 발생하지 않도록 멀티프로그래밍 정도를 낮춘다.
2. Stack 중심의 시스템에서는 Stack Pointer를 변경하여 프로세스간 문맥교환 수행
3. Light Weight 프로세스인 스레드를 이용하여 Context Switch 부하 최소화

## 가상메모리

> 프로세스 전체가 메모리 내에 올라오지 않아도 실행이 가능하도록 하는 기법

- 장점

1. 프로그램이 더이상 물리 메모리 크기에 제약받지 않게된다.
2. 더 많은 프로그램을 동시에 실행 할 수 있게 된다. (CPU의 이용률과 처리율이 올라간다)
3. 프로그램을 메모리에 올리고 swap하는데 필요한 입출력 횟수가 줄어들기 때문에 프로그램이 보다 빨리 샐행된다.

- 역할

1. 논리 메모리를 물리 메모리로부터 분리시켜 주는 것
2. 가상 메모리는 페이지 공유를 통해 파일이나 메모리가 둘 이상의 프로세스들에 공유되는 것을 가능하게 한다.

## PCB (Process Control Block)

> 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조

프로세스 제어 블록(PCB) 또는 태스크 제어 블록(TCB : Task control block), 프로세스 디스크립터로도 불리며, 운영체제에게 프로세스에 대한 중요한 정보를 제공해주는 자료구조 테이블. 운영체제가 CPU를 다른 프로세스에게 넘겨주고자 할 때, 프로세스에 관한 모든 정보를 PCB에 저장시키고 나서 다시 실행하고자 할 때는 PCB에 보관된 정보를 재사용.

PCB에 저장되는 정보

- 프로세스 식별자 (Process ID, PID)
- 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태 저장
- 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
- CPU 레지스터
- CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케쥴 큐에 대한 포인터 등
- 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
- 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

## 프로세스

> 현재 실행 중이거나 곧 실행이 가능한 프로세스 디스크립터(PCB)를 가진 프로그램.

프로세스는 최소 하나 이상의 스레드를 가지고 있다.
하드디스크에 있는 프로그램을 실행하면, 메모리 할당이 이루어지고 할당된 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간 부터 프로세스라고 불리게 된다.

메모리 구조는 **Code**, **Data**, **Heap**, **Stack**영역으로 나뉘게 된다.

- Code 영역 : 프로그램을 실행시키는 실행파일 내의 명령어들이 올라간다
- Data 영역 : 전역변수, static 변수의 할당
- Heap 영역 : 동적할당을 위한 메모리 영역
- Stack 영역 : 지역변수, 함수 호출시 전달되는 파라미터를 위한 메모리 영역

## 프로세스 상태변화

- new -> ready : new 상태에서 프로세스가 생성되게 되면 OS 커널에 존재하는 Ready queue에 올라간다

- ready -> running : Ready queue에 있는 프로세스들을 OS가 위에서 말한 프로세스 스케줄링 알고리즘에 의해서 Running 상태로 가야할 프로세스를 CPU로 할당하게 된다. 그러면 프로세스가 Running 상태가 된다.

- running -> ready : 현재 running 상태에 있는 프로세스 A보다 Ready Queue에서 대기하고 있는 프로세스 B가 우선순위가 높으면, 선점 스케줄인 경우 프로세스 A는 Ready 상태로 오게되고 프로세스 B가 running 상태로 가서 CPU를 할당받게 됩니다.

- running -> blocked : 현재 running 상태에 있는 프로세스 A에서 입출력 이벤트가 발생했을 때 프로세스 A가 blocked 상태로 가게 된다.

- blocked -> ready : 입출력 이벤트가 종료된 프로세스는 다시 ready 상태로 오게 된다.

- running -> terminated : 프로세스 종료

ready, blocked 상태에는 여러 프로세스가 존재할 수 있다. 하지만 싱글코어 CPU에서 running 상태의 프로세스는 단 하나만 존재한다.

## 스레드

> 프로세스 내에서 분리된 실행 흐름

스레드는 메모리공간에서 Register , Stack만을 독립적으로 가지고 Code , Heap, Data 같은 전역 공간은 서로 공유한다.

여기서 Stack을 독립적으로 할당하는 이유를 알기위해선 Stack에 알아볼 필요가 있다.

Stack은 함수 호출시 전달되는 인자, 되돌아갈 주소 값 및 함수내에서 선언하는 변수를 저장하기 위해 사용되는 공간인데, 이러한 Stack이 독립적이라는 것은 독립적인 함수 호출이 가능하다 라는 뜻이다. 따라서 독자적인 실행흐름이 추가 된다는 의미이다.
즉, **실행 흐름 추가를 위한 최소 요건이 Stack의 독립화**이다.

이 특징은 멀티스레드가 멀티프로세스보다 빠른 이유이기도 하다.
멀티프로세스는 Context Switching이 일어날 때 마다 캐시메모리를 초기화 시켜야 하는데, 멀티 스레드의 경우 전역 공간을 공유하므로 초기화를 시킬 필요가 없다. 따라서 스레드가 프로세스보다 작게는 수배, 많게는 수십 배 빠른 원인이 된다.

## 페이징

## 세마포어

- 운영체제 또는 프로그램 작성 내에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호

- 공유자원에 접근할 수 있는 최대 허용치만큼만 동시에 사용자 접근이 가능하다.

- 쓰레드들은 리소스 접근 요청을 할 수 있고 세마포어에서는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우 (카운트 0) 다음 작업은 대기를 하게 된다.

## 뮤텍스

- 상호배제, 제어되는 섹션에 하나의 스레드만을 허용하기 때문에 해당 섹션에 접근하려는 다른 스레드를 강제로 막음으로써 첫번째 스레드가 해당 섹션을 빠져나올 때 까지 기다린다.

- 대기열 (큐) 의 구조

## 세마포어와 뮤텍스의 차이

- 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.

- 세마포어는 소유 불가능이지만 뮤텍스는 소유가 가능하다

- 동기화의 갯수가 다르다

## 동기화

Windows에는 스레드를 동기화 할 수 있는 다양한 커널 객체가 있다. 이벤트 타이머 세마포어 뮤텍스가 그것이다.

이론적으로는 뮤텍스와 바이너리 세마포어는 동일한 기능을 하기 때문에 헷갈리는 주제이다. 서로 다른 스레드가 객체에 동시에 접근할 수 없도록 하는 것이 주된 기능인데 실제 Windows에 구현된 이 두 객체는 조금 다른 특징을 가진다.

가장 큰 차이점은 **소유주**이다. 뮤텍스의 경우 커널 객체 중 유일하게 소유권 개념을 가지고 있다. 다른 모든 커널 객체는 소유권 개념이 없다.

소유권이란, 해당 커널 객체가 자신을 소유하고 있는 스레드 정보를 저장하고 있는 것이다. 동기화 객체의 경우 소유한다는 의미는 WaitForSingleObject를 통해서 진입에 성공했다는 것이다. 해당 함수를 통해서 뮤텍스나 세마포어를 소유한 경우 ReleaseMutex나 ReleaseSemaphore를 호출하기 전까지 해당 스레드가 객체를 소유하고 있는 것이다.

만약 A B 두 스레드가 있고, 동기화를 위해 뮤텍스나 세마포를 사용해야 하는 상황이다. A 스레드가 WaitForSingleObject를 통해서 먼저 객체를 소유했다고 가정하자 그렇다면 이 상황에서 B 스레드가 ReleaseMutex나 ReleaseSemaphore를 통해서 소유된 해당 객체를 해제하려는 시도를 하면 어떻게 될까? 여기서 뮤텍스와 세마포어의 차이가 나타난다.

뮤텍스의 경우는 소유권을 저장하고 있기 때문에 false를 리턴한다. 그리고 GetLastError 값으로 해당 커널 오프젝트의 소유권을 ReleaseMutex를 호출한 스레드가 가지고 있지 않다는 것으로 설정한다. 반면 세마포어는 합법적으로 해당 요구를 처리한다.

소유권은 위와 같은 보안상의 장점을 가지고 있지만 해제되지 않은 뮤텍스의 소유권과 관련된 새로운 문제를 야기 시킨다

## 교착상태 (DeadLock)

> 프로세스나 스레드가 서로 끝나기를 기다리는 상태

이러한 문제를 해결하기 위해서 데드락에 대해 명확하게 발생조건을 이해하고 예방하거나 회피해야한다.

- 데드락은 아래 4가지 조건을 동시에 충족하면 데드락이 발생한다

1. 자원에 대한 동시 접근 불가 (뮤텍스)

한번에 여러 프로세스 혹은 스레드가 한 자원에 접근하지 못하도록 막는 것

2. 점유하고 기다리기

자원을 가지고 있는 상태에서 다른 프로세스가 쓰는 자원을 반납하길 기다리는 상태

3. 자원을 빼앗아오지 못함

다른 프로세스가 이미 점유한 자원을 강제로 뺏어오지 못한다.

4. 순환 형태로 대기

각자의 프로세스가 하고자 하는 바가 있을 텐데 이를 위해 기다리는 상태를 추적하다보니 결국 나 자신 프로세스가 나오는 상황

- 데드락 예방

데드락은 위 4가지 사항이 만족되야 발생하는 만큼, 그 중 하나라도 발생하지 않도록 시스템 차원에서 막아버리면 가능하다. 하지만 이 방법은 자원이 낭비되는 경향이 있다. 또한 발생 가능성을 원천봉쇄하려면 성능이 나빠지거나 또 다른 문제를 발생시킬 수 있다.

- 데드락 회피

> 교착상태의 원칙적인 발생 가능성은 놔두고, 발생을 막는 알고리즘을 적용해서 해결하는 방법이다.

은행원 알고리즘, 자원할당 그래프 알고리즘 등이 있다.

- 데드락의 탐지와 회복

> 교착상태가 발생하는 것조차 막지않는 방법이다. 발생하면 해결하겠다는 방법

- 데드락 무시

> 데드락이 거의 무시해도 좋을 정도의 확률이라고 판단되면 그냥 무시하는 방법

데드락 문제는 해결하려면 성능상 손해를 봐야하기 때문이다.

## SDN

> Software Defined Network의 약자로 기존에 자유롭게 활동하던 라우터들을 한데 묶어 중앙 집중형으로 컨트롤하게 하는 네트워크 가상화 접근 방식

SDN은 그전에 network layer에서 배운 컨트롤 플레인과 데이터 플레인을 분리하고, 물리적 장비와 구분되는 소프트웨어 프로그래밍 가능한 인프라를 생성하면서 구현된다.

- 왜 중앙 집중형 컨트롤 플레인일까?

중앙 집중 시, 네트워크를 관리하기 쉬워지고 트래픽 흐름이 매우 유연해진다.

## Ref.

https://ykcb.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C
https://m.blog.naver.com/PostView.nhn?blogId=yeop9657&logNo=220729107141&proxyReferer=https:%2F%2Fwww.google.com%2F
https://webie.tistory.com/99
https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS
http://www.jiniya.net/tt/527
https://suhwanc.tistory.com/112
