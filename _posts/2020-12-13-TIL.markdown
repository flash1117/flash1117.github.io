---
layout: post
title: '스프링부트 공부'
date: 2020-12-13 13:00:59
author: mollangzzang
categories: TIL
tags: TIL
cover: '/assets/TIL.png'
---

TDD와 단위테스트는 다른이야기이다.
TDD는 **테스트가 주도하는 개발**이다. 따라서 테스트 코드를 먼저 작성하는 것 부터 시작한다.

- 레드 그린 사이클

1. 항상 실패하는 테스트를 먼저 작성한다. (Red)
2. 테스트가 항상 통과하는 프로덕션 코드를 작성한다. (Green)
3. 테스트가 통과하면 프로덕션 코드를 리팩토링한다. (Refactor)

반면에 단위 테스트는 TDD의 첫번째 단계인 **기능 단위의 테스트 코드를 작성하는 것**을 이야기한다. TDD와 달리 테스트 코드를 꼭 먼저 작성해야 하는 것도 아니고, 리팩토링도 포함되지 않는다. 순수하게 테스트 코드를 작성하는 것만을 이야기한다.

## 단위테스트의 장점

- 개발단계 초기에 문제를 발견하게 도와준다.
- 개발자가 나중에 코드를 리팩토링하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지 확인할 수 있다. ex) 회귀테스트
- 단위테스트는 기능에 대한 불확실성을 감소시킬 수 있다.
- 단위테스트는 시스템에 대한 실제 문서를 제공한다. 즉, 단위테스트 자체가 문서로 사용할 수 있다.

테스트코드를 작성하면 더는 사람이 눈으로 검증하지 않게 **자동 검증**이 가능하다. 작성된 단위테스트를 실행만 하면 더는 수동검증이 필요없게 되는 것이다.

개발자가 만든 기능을 안전하게 보호해준다. 가령 B기능이 잘 되어서 오픈했더니 잘되던 A에 문제가 생기는 경우가 규모가 큰 서비스에서는 생각보다 빈번하다. 하나의 기능을 추가할 때마다 너무나 많은 자원이 들기 때문에 **서비스의 모든 기능을 테스트 할 수는 없다.**

이 때 기존 기능이 잘 작동되는 것을 보장해주는 것이 테스트 코드이다. A라는 기존 기능에 해당하는 알맞은 테스트 코드들을 작성해놓았다면 수행만 함으로써 문제를 초기에 발견할 수 있다.

테스트 코드 작성을 도와주는 프레임워크는 여러개가 있지만 대표적인 것은 xUnit이다.

대표적인 xUnit 프레임워크는 아래와 같다.

JUnit - Java
DBUnit - DB
CppUnit - C++
NUnit - .net

일반적으로 패키지명은 웹사이트 주소의 역순으로 한다. 예를들어서 `www.naver.com`이라는 사이트라면 패키지명은 `com.naver.www`가 되는 형식이다.

`@SpringBootApplication` 으로 인해서 스프링 부트의 자동설정, 스프링 Bean 읽기와 생성을 모두 자동으로 설정된다. 특히 `@SpringBootApplication`이 있는 위치부터 설정을 읽어나가기에 이 클래스는 항상 프로젝트의 최상단에 위치해야 한다.

`SpringBootApplication.run` 으로 인해서 내장 WAS를 사용하기 때문에 항상 서버에 톰캣을 설치할 필요가 없게 되고 스프링 부트로 만들어진 Jar 파일(실행 가능한 Java 패키징 파일)로 실행하면 된다.

내장 WAS를 사용하면 성능적인 이슈가 있지 않는가? 라는 주제가 있는데, 대표적인 WAS인 톰캣 역시 서블릿으로 이루어진 자바 애플리케이션이다. 따라서 똑같은 코드를 사용하기에 성능상 이슈는 크게 고려할 문제가 아니라고 한다.

오히려 외장 WAS를 사용함으로써 모든 서버가 같은 WAS환경을 구축할 수 있게 할 때 서버가 많을 수록 실수할 여지가 많아지기에 많은 회사들이 내장 WAS로 옮겨가는 추세이다.

`@RestController`

- 컨트롤러를 JSON을 반환하는 컨트롤러로 만들어준다.
- 예전에는 `@ResponseBody`를 각 메소드마다 선언했던 것을 한번에 사용할 수 있게 만들어준 것

`@GetMapping`

- HTTP Method인 Get의 요청을 받을수 있는 API를 만들어준다.
- 예전에는 `@RequestMapping(method=RequestMethod.GET)`으로 사용되었었다. 이제 해당 프로젝트는 `/hello`로 요청이 오면 문자열 hello를 반환하는 기능을 가지게 되었다.

`@RunWith(SpringRunner.class)`

- 테스트를 진행할 때 JUnit에 내장된 실행자 외에 다른 실행자를 실행시킨다.
- 여기서는 SpringRunner라는 스프링 실행자를 사용한다.
- 스프링 부트 테스트와 JUnit 사이에 연결자 역할을 한다.

`@WebMvcTest`

- 여러 스프링 테스트 어노테이션 중, Web(Spring MVC)에 집중할 수 있는 어노테이션이다.
- 선언할 경우 `@Controller` , `@ControllerAdvice` 등을 사용할 수 있다.
- 단 `@Service`, `@Component`, `@Repository` 등은 사용할 수 없다.
- 여기서는 컨트롤러만 사용하기에 선언한다.

`@Autowired`

- 스프링이 관리하는 빈을 주입 받는다.

`private MockMvc mvc`

- 웹 API를 테스트 할 때 사용한다.
- 스프링 MVC 테스트의 시작점이다.
- 이 클래스를 통해 HTTP GET, POST 등에 대한 API를 테스트 할 수 있다.

`mvc.perfome(get("/hello"))`

- MockMvc를 통해 `/hello` 주소로 HTTP GET 요청을 한다.
- 체이닝이 지원되어 아래와 같이 여러 검증 기능을 이어서 선언이 가능하다.

`.andExpect(status().isOk())`

- `mvc.perform`의 결과를 검증한다.
- HTTP Header의 Status를 검증한다.
- 우리가 흔히 알고 있는 200, 404, 500 등의 상태를 검증한다.
- 여기선 OK 즉, 200 인지 아닌지를 검증한다.

`.andExpect(content().string(hello))`

- mvc.perform의 결과를 검증한다.
- 응답 본문의 내용을 검증한다.
- Controller에서 `hello`를 리턴하기에 이 값이 맞는지 검증한다.

롬복은 프로젝트마다 설정해야한다. 플러그인 설치는 한번만 하면 되지만, build.gradle에 라이브러리를 추가하는 것과 Enable annotation processing을 체크하는 것은 프로젝트마다 진행해야 한다.
