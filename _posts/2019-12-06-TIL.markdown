---
layout: post
title:  "Stack & Heap Segment"
date:   2019-12-06 13:00:59
author: mollangzzang
categories: TIL
tags:	TIL Algorithm
cover:  "/assets/TIL.png"
---

다익스트라 알고리즘 문제를 푸는 도중 그래프를 입력 받을 일이 있었는데, 배열을 생성하려니 2만 x 2만 의 크기를 선언해야 될 경우가 생겼다. 하지만 **이미지 크기가 허용 가능한 최대 크기를 초과합니다** 라는 오류 메세지를 받았는데, 이 오류메세지를 본 순간 스택의 영역과 힙 영역에 관한 문제가 아닐까 해서 생각난 김에 다시 공부해보려고 한다.

프로그램이 사용하는 메모리는 일반적으로 세그먼트(segment) 라고 하는 몇 가지의 다른 영역으로 나뉜다.

- 코드 세그먼트 : 컴파일된 프로그램이 저장되는 영역, 일반적으로 **read-only** 속성이다. 텍스트 영역이라고도 부르며 CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 된다.

- 데이터 세그먼트 : 전역 변수 및 정적(static) 변수가 저장되는 영역으로, 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸하게 된다.

- 힙 세그먼트 : 동적으로 할당된 변수가 할당되는 영역

- 스택 세그먼트 : 함수 매개 변수, 지역 변수 및 기타 함수 관련 정보가 저장되는 영역으로 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸하게 된다.

#### Heap Segment

- **힙 세그먼트**는 동적 메모리 할당에 사용되는 메모리를 추적하게 된다. Java, C++ 의 경우 `new` 연산자를, c에서는 `malloc` 연산자를 사용해서 메모리를 할당하면 이 메모리는 응용 프로그램의 힙 세그먼트에 해당하게 된다.

- 사용자가 직접적으로 관리해야만 하는 영역이며, 메모리의 낮은 주소에서 높은 주소의 방향으로 할당 되게 된다.

```
int *pt = new int;
int *Array = new int[10];
```

- 여기서 pt 는 heap 에서 4byte , Array는 40byte로 할당되게 된다.

힙에는 장단점이 있는데, 

- 힙에 메모리를 할당하는 것이 비교적 느리다.

- 할당된 메모리는 명시적으로 할당 해제하거나 응용프로그램이 종료될 때 까지 유지되게된다. (메모리 릭 주의)

- 동적으로 할당된 메모리는 포인터를 통해 접근한다.
    - 포인터를 역참조하는 것은 변수에 직접 접근하는 것보다 느리다.

- 힙은 큰 메모리 풀이므로 큰 배열, 구조체 또는 클래스를 할당할 수 있다.

#### Stack Segment

- **스택 세그먼트**는 메인 함수부터 현재 실행 지점까지의 모든 활성 함수를 추적하고 모든 함수 매개 변수와 지역 변수의 할당을 처리한다.

- 스택은 LIFO 구조이다. 가장 늦게 들어간 자료를 가장 먼저 꺼내게 되는데, 함수 호출이 끝나고 이전 함수로 돌아갈 때 이 함수의 바로 이전 함수로 돌아가야 한다. 따라서 **컴퓨터는 내부적으로 스택 세그먼트를 스택 자료구조로 구현한다.**

- 메모리의 높은 구조에서 낮은 주소의 방향으로 할당되게 된다.

- 응용 프로그램이 시작되면 메인 함수가 운영체제에 의해 호출스택에 푸시된다. 그 후 프로그램이 실행되게 되는데, 함수 호출이 발생하면 함수가 콜 스택에 푸시 된다. 현재 함수가 끝나면 해당 함수는 콜 스택에서 해제된다. 따라서 콜 스택에 푸시된 함수를 살펴보면 현재 실행 지점으로 이동하기 위해 호출된 모든 함수를 볼 수 있다.

    - **콜 스택**이란, 컴퓨터 프로그램에서 현재 실행 중인 서브루틴(함수)에 관한 정보를 저장하는 스택 자료구조이다.

- 콜 스택 자체는 고정된 크기의 메모리 영역이다. 여기서 콜 스택에 넣고 빼는 데이터 자체를 **스택 프레임**이라고 하며 스택 프레임은 하나의 함수 호출과 관련된 모든 데이터를 추적한다. 또는 **스택 포인터**라고 하는 CPU의 작은 조각인 **레지스터**는 현재 호출 스택의 최상위 위치를 가리킨다.

스택의 장단점은

- 스택에 메모리를 할당하는 것은 비교적 빠르다.

- 스택에 할당된 메모리는 스택 범위에 있을 때만 접근이 가능하다.

- 스택에 할당된 모든 메모리는 컴파일 타임에 알려진다.

- 메모리는 변수를 통해 직접 접근할 수 있다.

- 스택은 비교적 크기가 작으므로 스택 공간을 많이 차지하는 지역 변수를 만드는 것은 좋지 못한 선택이다.

- 메모리를 할당한 뒤 해제하지 않으면 메모리 누수가 발생하게 된다.

#### Call Stack in Action

1. 프로그램에 함수 호출이 발생한다.

2. 스택 프레임이 생성되고 콜 스택이 푸시된다.

3. 스택 프레임은 아래와 같이 구성된다.
    - 함수가 종료되면 복귀할 주소
    - 함수의 모든 매개 변수
    - 지역 변수
    - 함수가 반환할 때 복원해야 하는 수정된 레지스터의 복사본

4. CPU 가 함수의 시작점으로 점프한다.

5. 함수 내부의 명령어를 실행한다.

함수가 종료 되게 된다면 아래와 같은 단계가 수행된다.

1. 레지스터가 콜 스택에서 복원된다.

2. 스택 프레임이 콜 스택에서 튀어나온다. 이렇게 되면 모든 지역 변수와 매개 변수에 대한 메모리가 해제된다.

3. 반환값이 처리된다.

4. CPU는 반환 주소에서 실행을 재개한다.

반환 값은 시스템 아키텍쳐에 따라 여러자기의 방법을 처리된다.

#### Stack Overflow

- 스택 세그먼트는 크기가 제한되어 있으므로 제한된 양의 데이터만 저장할 수 있다. window 운영체제에서 기본 스택 세그먼트의 크기는 1MB 이며, 크기제한은 OS마다 다르다.

- 스택 오버플로는 말 그래도 스택에서 흘러넘치는 것이며, 발생하게 된다면 프로그램이 다운되게 된다. 가장 흔한 예를 들어본다면 배열의 크기할당이 크거나, 재귀를 통하여 무한히 호출하게 된다면 스택메모리가 꽉 차서 오버플로가 발생하게 된다.

##### Ref.
[Link](https://boycoding.tistory.com/235)