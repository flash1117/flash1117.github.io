---
layout: post
title:  "Java 문법 - 객체"
date:   2019-10-27 13:00:59
author: mollangzzang
categories: TIL
tags:	TIL Java
cover:  "/assets/TIL.png"
---

#### 객체

- 객체는 속성과 기능의 집합이며, 속성과 기능을 객체의 멤버라고 한다.

- 클래스를 정의할 때 객체의 속성은 변수로, 기능은 메서드로 정의한다.

#### 선언 위치에 다른 변수의 종류

- **클래스 변수** 

    - 같은 클래스의 모든 인스턴스들이 공유하는 변수
    - 인스턴스 생성없이 **클래스이름.클래스변수명**으로 접근
    - 클래스가 로딩될 때 생성되고 프로그램이 종료될 때 소멸

- **인스턴스 변수**

    - 각 인스턴스의 개별적인 저장공간이며 인스턴스마다 다른 값 저장이 가능하다.
    - 인스턴스 생성 후 **참조변수.인스턴스변수명**으로 접근이 가능하다.
    - 인스턴스를 생성할 때 생성되고, 참조변수가 없을 때 garbagecollector 에 의해 자동적으로 제거가 된다.

- **지역 변수**

    - 메서드 내에 선언되며, 메서드의 종료와 함께 소멸된다. 또한 조건문 , 반복문의 블럭 내에 선언된 지역변수는 블럭을 벗어나면 소멸된다.

- 인스턴스 변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 가지게 된다.

- 인스턴스 변수는 그냥 클래스 내부에 일반적인 변수명을 선언 하듯이 하면 되고, 클래스 변수는 `static int width = 100;` 와 같은 방식으로 선언한다.

#### 메서드

- 메서드는 클래스 영역에만 정의할 수 있다.

#### JVM의 메모리 구조

- **메서드 영역 (Method Area)**
    - 클래스 정보와 클래스 변수가 저장되는 곳

- **호출 스택 (Call Stack)**
    - 메서드의 작업공간. 메서드가 호출되면 메서드 수행에 필요한 메모리공간을 할당받고 메서드가 종료되면 사용하던 메모리를 반환하게 된다.

    - 호출 스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다

    - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

- **힙 (Heap)**
    - 인스턴스가 생성되는 공간. new 연산자에 의해서 생성되는 배열과 객체는 모두 여기에 생성된다.

#### 클래스 메서드 (static method) 와 인스턴스 메서드

- **인스턴스 메서드**
    - 인스턴스 생성 후, **참조변수.메서드이름()**으로 호출
    - 인스턴스 변수나 인스턴스 메서드와 관련된 작업을 하는 메서드
    - 메서드 내에서 인스턴스 변수 사용가능

- **클래스 메서드**
    - 객체 생성없이 **클래스이름.메서드이름()**으로 호출
    - 인스턴스 변수나 인스턴스 메서드와 관련없는 작업을 하는 메서드
    - 메서드 내에서 인스턴스 변수 사용 불가
    - 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.

- **같은 클래스의 멤버간에는 객체생성이나 참조변수 없이 참조할 수 있다. 그러나 static멤버들은 인스턴스멤버들을 참조할 수 없다.**

#### 메서드 오버로딩

- 하나의 클래스에 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩이라고 한다.

- 매개변수는 다르나 같은 의미의 기능수행을 하고 싶을 때 사용하는 것

- 메서드 오버로딩의 조건
    - 메서드의 이름이 같아야 한다.
    - 매개변수의 개수 또는 타입이 달라야 한다.
    - 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않는다.

#### 생성자

- 인스턴스가 생성될 때마다 호출되는 **인스턴스 초기화 메서드**

- 인스턴스 변수의 초기화 또는 인스턴스 생성시 수행할 작업에 사용

- 몇가지 조건을 제외한 나머지는 메서드와 유사하다.

- 모든 클래스에는 반드시 하나 이상의 생성자가 있어야 한다.

#### 생성자의 조건

- 생성자의 이름은 클래스의 이름과 같아야 한다.

- 생성자는 리턴값이 없다.

#### 기본 생성자

- 매개변수가 없는 생성자

- 클래스에 생성자가 하나도 없으면 컴파일러가 기본 생성자를 추가한다. (생성자가 하나라도 존재한다면 컴파일러는 기본 생성자를 추가하지 않는다.)

#### 생성자에서 다른 생성자 호출하기

- **this()** - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용. 다른 생성자 호출은 생성자의 첫 문장에서만 가능

```
Class Car {

    String color;
    String gearType;
    int door;

    Car() {

        color = "white";
        gearType = "auto";
        door = 4;
    }

    car(String c, String g, int d) {
        color = c;
        gearType = g;
        door = d;
    }

}
```

같은 경우에서 `Car()` 부분의 코드 재사용성을 높일 수가 있는데,

```
Car() {
    this("white", "auto", 4);
}
```
와 같이 변경할 수가 있다.

#### 참조변수 this

- **this** : 인스턴스 자신을 가리키는 참조변수로, 인스턴스의 주소가 저장되어있다. 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다.

위 코드에서 두번째 `car()` 메서드를 

```
Car(String color , String gearType, int door)
{
    this.color = color;
    this.gearType = gearType;
    this.door = door;
}
```
과 같은 식으로 변경이 가능하며, 이렇게 사용하는 이유는 인스턴스 변수와 지역변수를 구별하기 위해서 참조변수 **this** 를 사용한다.

#### 변수의 초기화

- 지역변수는 사용전에 초기화를 하여야 한다.

- 멤버변수 (인스턴스 변수, 클래스 변수) 와 배열은 각 타입의 기본값으로 자동초기화 되므로 초기화를 생략이 가능하다.

|자료형|기본값|
|:--:|:--:|
|boolean|false|
|char|'\u0000'|
|byte|0|
|short|0|
|int|0|
|long|0|
|float|0.0f|
|double|0.0d or 0.0|
|참조형 변수|null|

- 타입이 다른 변수는 함께 선언하거나 초기화 할 수 없다.

#### 초기화 블럭 (initialization block)

- 클래스 초기화 블럭 - 클래스 변수의 복잡한 초기화에 사용되며 클래스가 로딩될 때 실행된다.

- 인스턴스 초기홥 블럭 - 생성자에서 공통적으로 수행되는 작업에 사용되며 인스턴스가 생성될 때마다 생성자보다 먼저 실행된다.

```
class StaticBlockTest {

    static int [] arr = new int[10];
    static {
        for(int i =0; i<arr.length; i++)
            arr[i] = (int)(Math.random()*10) +1;
    } // 클래스 초기화 블럭
    // 인스턴스의 경우 static 을 붙이지 않는다.
}

```

#### 멤버변수의 초기화 시기와 순서

- 클래스변수 초기화 시점 : 클래스가 처음 로딩될 때 단 한번

- 인스턴스변수 초기화 시점 : 인스턴스가 생성될 때 마다

```
class Product {

    static int count = 0;
    int serialNo;
    {
        ++count;
        serialNo = count;
    }
    public Product() {}
}

class ProductTest {

    public static void main(String args[]) {
        Product p1 = new Product();
        Product p2 = new Product();
        Product p3 = new Product();

        System.out.println("p1의 제품번호는 " + p1.serialNo);
        System.out.println("p2의 제품번호는 " + p1.serialNo);
        System.out.println("p3의 제품번호는 " + p1.serialNo);
        System.out.println("생산된 제품의 수는 모두" + Product.count + "개 입니다.");
    }
}

```
